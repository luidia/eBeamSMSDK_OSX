//
//  DrawView.m
//  PenTestOSX
//
//  Created by Luidia on 2019
//  Copyright © 2019년 Luidia. All rights reserved.
//

#import "DrawView.h"
#import "PNFStrokePoint.h"
#import "PNFDefine.h"

@interface StrokePoints : NSObject
{
	CGPoint		pt;
	float		press;
}
@property(readwrite) CGPoint pt;
@property(readwrite) float press;
@end

@implementation StrokePoints
@synthesize pt;
@synthesize press;
@end

@implementation DrawView
@synthesize figureList, strokeList;
@synthesize rtRender, nRenderedIdx, nDrawingPoint;
@synthesize isWrite;


- (id)initWithFrame:(NSRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        [self initDraw];
    }
    return self;
}
-(void) initDraw {
    self.figureList =  [[[NSMutableArray alloc] init]autorelease]  ;
    self.strokeList =  [[[NSMutableArray alloc] init]autorelease]  ;
    m_PenColor = [[NSColor colorWithCalibratedRed:0 green:0 blue:0 alpha:1] retain];
    m_nPenThick = 2.0f;
    CGRect f = self.bounds;
    if (cgContextMain) 	CGContextRelease(cgContextMain);
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef ctx = CGBitmapContextCreate(NULL,
                                             f.size.width, f.size.height,
                                             8, 4*f.size.width,
                                             colorSpace,
                                             kCGImageAlphaPremultipliedLast|kCGBitmapByteOrder32Big);
    cgContextBitmap=ctx;
    m_ImageRef = CGBitmapContextCreateImage(cgContextBitmap);
    m_MainLayer = CGLayerCreateWithContext(ctx, f.size, NULL);
    cgContextMain = CGLayerGetContext(m_MainLayer);
    CGColorSpaceRelease(colorSpace);
    CGContextClearRect(cgContextMain,self.frame);
    cgLayer = CGLayerCreateWithContext(cgContextMain, f.size, NULL);
    cgContextLayer = CGLayerGetContext(cgLayer);
    m_rectMain = f;
    
    isWrite = NO;
    
    downFlag = NO;
    initFlag = YES;
    
    initOffset = CGPointMake(50, 50);
    startOffset = CGPointZero;
    
    [self SetDrawConfig:cgContextMain];
    [self SetDrawConfig:cgContextBitmap];
}
#if 0
-(void) mouseDown:(NSEvent *)theEvent {
    CGPoint pt = [self convertPoint:[theEvent locationInWindow] fromView:nil ];
    [self DoMouseDown:pt pressure:1];
}
-(void) mouseDragged:(NSEvent *)theEvent {
    CGPoint pt = [self convertPoint:[theEvent locationInWindow] fromView:nil ];
    [self DoMouseMove:pt pressure:1];
}
-(void) mouseUp:(NSEvent *)theEvent {
    CGPoint pt = [self convertPoint:[theEvent locationInWindow] fromView:nil ];
    [self DoMouseUp:pt pressure:1];
}
#endif
-(void) clear {
    isWrite = NO;
    [self.strokeList removeAllObjects];
    self.strokeList = nil;
    [self.figureList removeAllObjects];
    self.figureList = nil;
    CGContextClearRect(cgContextBitmap, m_rectMain);
    CGContextClearRect(cgContextMain, m_rectMain);
    CGContextClearRect(cgContextLayer, m_rectMain);
    [self setNeedsDisplay:YES];
}
-(void) drawRect:(CGRect)dirtyRect {
    [[NSColor whiteColor] set];
    NSRectFill([self bounds]);
    
    CGContextRef ctx = [[NSGraphicsContext currentContext] graphicsPort];
    CGContextDrawLayerInRect(ctx, self.bounds, m_MainLayer);
}
-(void) SetDrawConfig:(CGContextRef) ctx {
    const CGFloat *compoments = CGColorGetComponents(m_PenColor.CGColor);
    CGContextSetLineDash(ctx, 0, nil, 0);
    CGContextSetAllowsAntialiasing(ctx, YES);
    CGContextSetShouldAntialias(ctx, YES);
    CGContextSetRGBStrokeColor(ctx, compoments[0],compoments[1],compoments[2], 1.0);
    CGContextSetLineWidth(ctx, m_nPenThick);
    CGContextSetLineJoin(ctx, kCGLineJoinRound);
    CGContextSetLineCap(ctx, kCGLineCapRound);
}

-(void) AddStrokePoint:(CGPoint)pt Pressure:(float)press {
	StrokePoints* sp = [[[StrokePoints alloc] init] autorelease];
	sp.pt = pt;
	sp.press = press;
    if (self.strokeList.count == 0) {
        CGPoint point = CGPointMake(sp.pt.x-initOffset.x, sp.pt.y-initOffset.y);
        startOffset = CGPointMake(point.x, point.y);
    }

    [self.strokeList addObject:sp];
}
-(void) DoMouseDown:(CGPoint) p pressure:(int)pressure {
    // init var
    self.strokeList =  [[[NSMutableArray alloc] init]autorelease] ;
    [self.figureList addObject:self.strokeList];
    nDrawingPoint = 0;
    nRenderedIdx = 0;
    
    // add stroke
    [self AddStrokePoint:p Pressure:pressure];
    
    // rendering
    [self RenderingView];
}
-(void) DoMouseMove:(CGPoint) p pressure:(int)pressure {
    nDrawingPoint++;
    [self AddStrokePoint:p Pressure:pressure];
    [self DrawLastStroke:cgContextMain ScreenMode:YES];
    [self RenderingView];
}
-(void) DoMouseUp:(CGPoint) p pressure:(int)pressure {
    int c = (int)(self.strokeList.count-1);
    if (c > 0) {
        CGPoint	previousPoint1;
        CGPoint	previousPoint2;
        CGPoint	currentPoint;
        StrokePoints* ps;
        if (c == 1 ) {
            ps = [self.strokeList objectAtIndex:0];
            previousPoint1 = ps.pt;
            previousPoint2 = previousPoint1;
        }
        else if(c == 2 ){
            ps = [self.strokeList objectAtIndex:0];
            previousPoint2 = ps.pt;
            ps = [self.strokeList objectAtIndex:1];
            previousPoint1 = ps.pt;
        }
        else {
            ps = [self.strokeList objectAtIndex:c-2];
            previousPoint2 = ps.pt;
            ps = [self.strokeList objectAtIndex:c-1];
            previousPoint1 = ps.pt;
        }
        
        ps = [self.strokeList lastObject];
        currentPoint = ps.pt;
        
        //CGPoint mid1 = BizMidPoint(previousPoint1, previousPoint2);
        CGPoint mid1 = CGPointMake((previousPoint1.x + previousPoint2.x)/2, (previousPoint1.y + previousPoint2.y)/2);
        CGPoint mid2 = currentPoint;
        CGContextMoveToPoint(cgContextMain, mid1.x, mid1.y);
        CGContextAddQuadCurveToPoint(cgContextMain, previousPoint1.x, previousPoint1.y, mid2.x, mid2.y);
        CGContextStrokePath(cgContextMain);
    }
    CGContextClearRect(cgContextBitmap, m_rectMain);
    CGContextDrawLayerInRect(cgContextBitmap, m_rectMain, m_MainLayer);
    [self setNeedsDisplay:YES];
}
-(void) DrawLastStroke:(CGContextRef) ctx ScreenMode:(BOOL) bScreenMode {
    [self DrawLastStroke:ctx ScreenMode:bScreenMode LastIdx:-1];
}
-(void) DrawLastStroke:(CGContextRef) ctx ScreenMode:(BOOL) bScreenMode LastIdx:(int) nLastIdx {
    // use bezier path
    unsigned long c;
    if (nLastIdx == -1) {
        c = [strokeList count]-1;
    }
    else {
        c = nLastIdx+1;
    }
    CGPoint	previousPoint1;
    CGPoint	previousPoint2;
    CGPoint	currentPoint;
    StrokePoints* ps;
    if (c == 1 ) {
        ps = [self.strokeList objectAtIndex:0];
        previousPoint1 = ps.pt;
        previousPoint2 = previousPoint1;
        currentPoint = previousPoint2;
    }
    else if(c == 2 ){
        ps = [self.strokeList objectAtIndex:0];
        previousPoint2 = ps.pt;
        previousPoint1 = ps.pt;
        ps = [self.strokeList objectAtIndex:1];
        currentPoint = ps.pt;
    }
    else {
        ps = [self.strokeList objectAtIndex:c-3];
        previousPoint2 = ps.pt;
        ps = [self.strokeList objectAtIndex:c-2];
        previousPoint1 = ps.pt;
        ps = [self.strokeList objectAtIndex:c-1];
        currentPoint = ps.pt;
    }
    
    //CGPoint mid1 = BizMidPoint(previousPoint1, previousPoint2);
    //CGPoint mid2 = BizMidPoint(currentPoint, previousPoint1);
    CGPoint mid1 = CGPointMake((previousPoint1.x + previousPoint2.x)/2, (previousPoint1.y + previousPoint2.y)/2);
    CGPoint mid2 = CGPointMake((currentPoint.x + previousPoint1.x)/2, (currentPoint.y + previousPoint1.y)/2);
    if (bScreenMode) {
        CGContextMoveToPoint(ctx, mid1.x, mid1.y);
    }
    else {
        CGContextMoveToPoint(ctx, mid1.x, mid1.y);
    }
    
    CGContextAddQuadCurveToPoint(ctx, previousPoint1.x, previousPoint1.y, mid2.x, mid2.y);
    
    if (bScreenMode) {
        CGContextStrokePath(ctx);
    }
    else {
        CGContextStrokePath(ctx);
    }
}
-(void) RenderingView {
    if (nDrawingPoint==0) {
        return;
    }
    NSMutableArray*	pStroke = self.strokeList;
    int p1 = nRenderedIdx < 2 ? 0 : nRenderedIdx-2;
    int p2 = nDrawingPoint;
    nRenderedIdx = p2;
    StrokePoints* ppt;
    float minX=999999;
    float minY=999999;
    float maxX=-999999;
    float maxY=-999999;
    for(int i=p1;i<=p2;i++) {
        if (i >= [pStroke count])
            break;
        ppt = [pStroke objectAtIndex:i];
        
        if (ppt.pt.x < minX) minX = ppt.pt.x;
        if (ppt.pt.y < minY) minY = ppt.pt.y;
        if (ppt.pt.x > maxX) maxX = ppt.pt.x;
        if (ppt.pt.y > maxY) maxY = ppt.pt.y;
    }
    float margin = 3.0f;//m_nPenThick;
    rtRender = CGRectMake(minX - margin,
                               minY - margin,
                               maxX - minX + margin*2,
                               maxY - minY + margin*2);
    [self setNeedsDisplayInRect:rtRender];
}
-(void) changeDrawingSize {
    [self clear];
    //    if (cgContextLayer) CGContextRelease(cgContextLayer);
    if (cgLayer) CGLayerRelease(cgLayer);
    //    if (cgContextMain) CGContextRelease(cgContextMain);
    if (m_ImageRef) CGImageRelease(m_ImageRef);
    if (m_MainLayer) CGLayerRelease(m_MainLayer);
    if (cgContextBitmap) CGContextRelease(cgContextBitmap);
    
    cgContextLayer = nil;
    cgLayer = nil;
    cgContextMain = nil;
    m_ImageRef = nil;
    m_MainLayer = nil;
    m_MainLayer = nil;
    cgContextBitmap = nil;
    
    [self initDraw];

}

-(void) DoPenProcess:(int) penTip pressure:(int)pressure X:(float) x Y:(float) y color:(NSColor*)color erase:(BOOL)erase eraseSize:(float)eraseSize {
    switch (penTip) {
        case PEN_DOWN: {
            if (erase) {
                [m_PenColor release];
                m_PenColor = [color retain];
                m_nPenThick = eraseSize;
            }
            else {
                if (color) {
                    [m_PenColor release];
                    m_PenColor = [color retain];
                }
                else {
                    [m_PenColor release];
                    m_PenColor = [[NSColor colorWithRed:0 green:0 blue:0 alpha:1.0] retain];
                }
                m_nPenThick = 2;
            }
            [self SetDrawConfig:cgContextMain];
            [self SetDrawConfig:cgContextBitmap];
            
            [self DoMouseDown:CGPointMake(x, y) pressure:pressure];
            break;
        }
        case PEN_MOVE:
            [self DoMouseMove:CGPointMake(x, y) pressure:pressure];
            break;
        case PEN_UP:
            [self DoMouseUp:CGPointMake(x, y) pressure:pressure];
            break;
        case PEN_HOVER:
            break;
        default:
            break;
    }
}

@end
