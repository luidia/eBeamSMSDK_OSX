//
//  MainWindowController.m
//  PenTestOSX
//
//  Created by Luidia on 2019
//  Copyright © 2019년 Luidia. All rights reserved.
//

#import "MainWindowController.h"
#import "PNFPenLibOSXExtension.h"

#define AUDIO_DEV_MAX   255
#define AUDIO_USR_MAX   215

@interface MainWindowController () <NSTextFieldDelegate, BLESearchListViewControllerDelegate, DrawViewWindowControllerDelegate, MarkerCalibrationViewControllerDelegate>
{
    BOOL m_penConntectedStatus;
    int temperatureCnt;
    
    int downCnt;
    int moveCnt;
    int upCnt;
    
    int penErrorCnt;
    int packetCnt;
    float beforeRawX;
    float beforeRawY;
    int errCntX;
    int errCntY;
    
    CGSize curScreenSize;
    CGSize curDrawViewSize;
    
    BOOL isRecvEnvDataFirst;
    
    NSThread* readThread;
    BOOL      readThreadPause;
    BOOL      readThreadStop;
    
    enum CalibrationSize curCalibrationSize;
    NSColor* penColor;
    
    int curConnectModelCode;
    
    BOOL bIsShowAllowMsg;
}
@end

@implementation MainWindowController
@synthesize penController;
@synthesize m_BLESearchListController;
@synthesize m_MarkerCalibrationViewController;
@synthesize m_DrawViewWindowController;
@synthesize m_BTNameChangeViewController;
@synthesize m_VoiceChangeViewController;

-(void) dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"PNF_LOG_MSG" object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"PNF_PEN_READ_DATA" object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"PNF_MSG" object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"BLE_SEARCH_DEVICE_NAME" object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"PNF_BLE_STATE_MSG" object:nil];
    
    [super dealloc];
}

- (id)initWithWindow:(NSWindow *)window
{
    self = [super initWithWindow:window];
    if (self) {
        bIsShowAllowMsg = NO;
        self.m_BLESearchListController = nil;
        self.m_MarkerCalibrationViewController = nil;
        self.m_DrawViewWindowController = nil;
        self.m_BTNameChangeViewController = nil;
        self.m_VoiceChangeViewController = nil;
        curCalibrationSize = FT8X5;
        penColor = [NSColor blackColor];
        curConnectModelCode = -1;
    }
    return self;
}

- (void)windowDidLoad {
    [super windowDidLoad];
    
    isRecvEnvDataFirst = YES;
    
    curScreenSize = CGSizeMake(600, 700);
    curDrawViewSize = CGSizeMake(600, 700);
    
    self.m_BLESearchListController = nil;
    self.m_MarkerCalibrationViewController = nil;
    self.m_DrawViewWindowController = nil;
    self.m_BTNameChangeViewController = nil;
    self.m_VoiceChangeViewController = nil;
    
    packetCnt = 0;
    errCntX = 0;
    errCntY = 0;
    beforeRawX = -1;
    beforeRawY = -1;
    [self updatePacketCnt];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(FreeLogMsg:) name:@"PNF_LOG_MSG" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(PenHandlerWithMsg:) name:@"PNF_PEN_READ_DATA" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(PenCallBackFunc:) name:@"PNF_MSG" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(BLESearchDeviceName:) name:@"BLE_SEARCH_DEVICE_NAME" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(BLEState:) name:@"PNF_BLE_STATE_MSG" object:nil];
    
    [self setPNFPenLib];
    
    [bleSearchBtn setEnabled:NO];
    [bleDisconnectBtn setEnabled:NO];
}

-(void) setPNFPenLib {
    penController = [[PNFPenLibOSXExtension alloc] init];
    [penController setDefaultModelCode:eBeamSmartMarker];
    [penController setProjectiveLevel:4];
    [penController fixStationPosition:DIRECTION_LEFT];
    [penController BLEInit];
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
//    [penController setFilterOnOff:NO DispLog:NO];
}

- (BOOL)windowShouldClose:(NSWindow *)sender {
    [self closeSelf];
    return NO;
}

-(void) closeSelf {
    [self closeAllViewController];
    
    [NSApp stop:nil];
}

-(void) addDebugText:(NSString*)text {
    NSString* t = [NSString stringWithFormat:@"%@\n%@", debugTextView.string, text];
    [debugTextView setString:t];
    [debugTextView scrollRangeToVisible:NSMakeRange([debugTextView.string length], 0)];
}

-(void) BTErrorProcessRet:(NSAlert *)alert returnCode:(int)returnCode contextInfo:(void *)contextInfo {
    if (penController.bConnectedHID)
        return;
    if (returnCode == NSAlertFirstButtonReturn) {
        NSLog(@"first button try again");
    }
    else if(returnCode == NSAlertSecondButtonReturn)
    {
        NSLog(@"second button init");
        [penController InitBTConnection:curConnectModelCode];
        curConnectModelCode = -1;
    }
    else {
        curConnectModelCode = -1;
    }
}

-(void) BTErrorProcess {
    NSAlert* alert = [[[NSAlert alloc] init] autorelease];
    [alert addButtonWithTitle:@"Retry"];
    [alert addButtonWithTitle:@"Pairing"];
    [alert addButtonWithTitle:@"Cancel"];
    [alert setMessageText:@"Can not connect pen."];
    [alert setAlertStyle:NSInformationalAlertStyle];
    [alert beginSheetModalForWindow:self.window
                      modalDelegate:self
                     didEndSelector:@selector(BTErrorProcessRet:returnCode:contextInfo:)
                        contextInfo:NULL];
    
}

-(void) FreeLogMsg:(NSNotification *) note
{
    NSString * szS = (NSString *) [note object];
    if ([szS compare:@"FAIL_LISTENING"] == 0 ) {
        NSAlert* alert = [[[NSAlert alloc] init] autorelease];
        [alert addButtonWithTitle:@"Ok"];
        [alert setMessageText:@"abnormal connect. please reconnect device"];
        [alert setAlertStyle:NSInformationalAlertStyle];
        [alert beginSheetModalForWindow:self.window
                          modalDelegate:nil
                         didEndSelector:nil
                            contextInfo:NULL];
        return;
    }
    else if ([szS isEqualToString:@"CONNECTED"]) {
        [self addDebugText:szS];
        penErrorCnt = 0;
    }
    else if ([szS isEqualToString:@"INVALID_PROTOCOL"]) {
        [self addDebugText:@"INVALID_PROTOCOL"];
        [NSTimer scheduledTimerWithTimeInterval:1
                                         target:self
                                       selector:@selector(BTErrorProcess)
                                       userInfo:nil
                                        repeats:NO];
        return;
    }
    else if ([szS isEqualToString:@"UPDATE_BLE_RSSI"]) {
//        NSLog(@"penController.RSSI; = %d", penController.RSSI);
//        RSSIValue = penController.RSSI;
        return;
    }
    else if ([szS isEqualToString:@"FAIL_CONNECTING"]) {
        [self addDebugText:@"FAIL_CONNECTING"];
        [NSTimer scheduledTimerWithTimeInterval:1
                                         target:self
                                       selector:@selector(BTErrorProcess)
                                       userInfo:nil
                                        repeats:NO];
        return;
    }
    else if ([szS isEqualToString:@"SESSION_CLOSED"]) {
        [HIDTextField setStringValue:@""];
        [self addDebugText:szS];
        curConnectModelCode = -1;
    }
    else if ([szS isEqualToString:@"PEN_RMD_ERROR"]) {
        [self addDebugText:@"PEN_RMD_ERROR"];
        
        if (penController && (penController.PenStatus == PEN_DOWN || penController.PenStatus == PEN_MOVE)) {
            penErrorCnt++;
            NSLog(@"penErrorCnt = %d", penErrorCnt);
        }
        return;
    }
    else if ([szS isEqualToString:@"FIRST_DATA_RECV"]) {
        [self addDebugText:szS];
        
        curConnectModelCode = penController.modelCode;
        
        if (penController.AudioMode)
            [audioModeBtn setSelectedSegment:1];
        else
            [audioModeBtn setSelectedSegment:0];
        
        [volumeSlider setMinValue:0];
        [volumeSlider setMaxValue:AUDIO_USR_MAX];
        int value = AUDIO_DEV_MAX-(int)penController.Volume;
        if (value > AUDIO_USR_MAX) {
            value = AUDIO_USR_MAX;
            [penController changeVolume:AUDIO_DEV_MAX-AUDIO_USR_MAX];
        }
        [volumeSlider setDoubleValue:value];
        
        [modelCodeTextField setStringValue:[NSString stringWithFormat:@"%d", penController.modelCode]];
        [mcu1TextField setStringValue:[NSString stringWithFormat:@"%d", penController.MCU1Version]];
        [mcu2TextField setStringValue:[NSString stringWithFormat:@"%d", penController.MCU2Version]];
        [hwVerTextField setStringValue:[NSString stringWithFormat:@"%d", penController.HWVersion]];
        
        [HIDTextField setStringValue:@"Bluetooth"];
        
        if (penController.StationPosition == DIRECTION_LEFT) {
            [directionTextField setStringValue:@"Left"];
        }
        else if (penController.StationPosition == DIRECTION_RIGHT) {
            [directionTextField setStringValue:@"Right"];
        }
        else if (penController.StationPosition == DIRECTION_TOP) {
            [directionTextField setStringValue:@"Top"];
        }
        else if (penController.StationPosition == DIRECTION_BOTTOM) {
            [directionTextField setStringValue:@"Bottom"];
        }
        else {
            [directionTextField setStringValue:@"Both"];
        }
        
        [NSTimer scheduledTimerWithTimeInterval:3.0f
                                         target:self
                                       selector:@selector(lazyCheckCalibration)
                                       userInfo:nil
                                        repeats:NO];
    }
    else if ([szS isEqualToString:@"CLICK"] ||
             [szS isEqualToString:@"DOUBLE_CLICK"] ||
             [szS isEqualToString:@"Gesture Circle Clockwise"] ||
             [szS isEqualToString:@"Gesture Circle CounterClockwise"]) {
        [self addDebugText:szS];
        return;
    }
    else if ([szS isEqualToString:@"NOT_FOUND_HID_DEVICE"]) {
        
    }
    else
        return;
    
    [self checkPenConnect];
    packetCnt++;
    [self updatePacketCnt];
}
-(void) updateErrCntX {
    [errCntTextFieldX setStringValue:[NSString stringWithFormat:@"%d", errCntX]];
}
-(void) updateErrCntY {
    [errCntTextFieldY setStringValue:[NSString stringWithFormat:@"%d", errCntY]];
}

-(void) updatePacketCnt {
    [packetCntTextField setStringValue:[NSString stringWithFormat:@"%d", packetCnt]];
}

-(void) updateDrawCnt {
    [downCntTextField setStringValue:[NSString stringWithFormat:@"%d", downCnt]];
    [moveCntTextField setStringValue:[NSString stringWithFormat:@"%d", moveCnt]];
    [upCntTextField setStringValue:[NSString stringWithFormat:@"%d", upCnt]];
    [totalCntTextField setStringValue:[NSString stringWithFormat:@"%d", downCnt+moveCnt+upCnt]];
    float byte = 0;
    if (downCnt+moveCnt+upCnt == 0)
        [byteTextField setStringValue:[NSString stringWithFormat:@"%d", 0]];
    else {
        [byteTextField setStringValue:[NSString stringWithFormat:@"%d", ((downCnt+moveCnt+upCnt)*6)+((downCnt+moveCnt+upCnt)/12)+1]];
        byte = ((downCnt+moveCnt+upCnt)*6)+((downCnt+moveCnt+upCnt)/12)+1;
    }
    [kByteTextField setStringValue:[NSString stringWithFormat:@"%.3f", byte/1024.f]];
}

-(void) lazyCheckCalibration {
    if (![penController bExistCalibrationInfo]) {
        [self addDebugText:@"calibration data not exist"];
    }
    else {
        [self addDebugText:@"calibration data exist"];
    }
    
    if (penController.modelCode == Equil) {
        [self addDebugText:@"Equil"];
    }
    else if (penController.modelCode == EquilPro) {
        [self addDebugText:@"Equil 2"];
    }
    else if (penController.modelCode == EquilSmartMarker) {
        [self addDebugText:@"Equil Smartmarker"];
    }
    else if (penController.modelCode == eBeamSmartMarker) {
        [self addDebugText:@"eBeam Smartmarker"];
    }
    [self initCalibration];
    if (penController.modelCode == EquilSmartMarker || penController.modelCode == eBeamSmartMarker) {
        [self ReadThreadStart];
    }
    else{
        [self ReadThreadOff];
    }
}

-(void) checkPenConnect {
    if (m_penConntectedStatus == penController.bConnected) {
        return;
    }
    if (penController.bConnected) {
        m_penConntectedStatus = YES;
    }
    else {
        m_penConntectedStatus = NO;
    }
}

-(void) initCalibration {
    CGPoint calResultPoint[4];
    switch (penController.StationPosition) {
        case DIRECTION_LEFT: {
            FT_8X5()
            if (CGPointEqualToPoint(penController.deviceCalibrationData_0, calResultPoint[0]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_1, calResultPoint[1]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_2, calResultPoint[2]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_3, calResultPoint[3])) {
                curCalibrationSize = FT8X5;
            }
            else {
                calResultPoint[0] = CGPointMake(penController.deviceCalibrationData_0.x, penController.deviceCalibrationData_0.y);
                calResultPoint[1] = CGPointMake(penController.deviceCalibrationData_1.x, penController.deviceCalibrationData_1.y);
                calResultPoint[2] = CGPointMake(penController.deviceCalibrationData_2.x, penController.deviceCalibrationData_2.y);
                calResultPoint[3] = CGPointMake(penController.deviceCalibrationData_3.x, penController.deviceCalibrationData_3.y);
                curCalibrationSize = Custom;
            }
            break;
        }
        case DIRECTION_RIGHT: {
            FT_8X5()
            if (CGPointEqualToPoint(penController.deviceCalibrationData_0, calResultPoint[0]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_1, calResultPoint[1]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_2, calResultPoint[2]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_3, calResultPoint[3])) {
                curCalibrationSize = FT8X5;
            }
            else {
                calResultPoint[0] = CGPointMake(penController.deviceCalibrationData_0.x, penController.deviceCalibrationData_0.y);
                calResultPoint[1] = CGPointMake(penController.deviceCalibrationData_1.x, penController.deviceCalibrationData_1.y);
                calResultPoint[2] = CGPointMake(penController.deviceCalibrationData_2.x, penController.deviceCalibrationData_2.y);
                calResultPoint[3] = CGPointMake(penController.deviceCalibrationData_3.x, penController.deviceCalibrationData_3.y);
                curCalibrationSize = Custom;
            }
            break;
        }
        case DIRECTION_TOP: {
            FT_4X6()
            if (CGPointEqualToPoint(penController.deviceCalibrationData_0, calResultPoint[0]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_1, calResultPoint[1]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_2, calResultPoint[2]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_3, calResultPoint[3])) {
                curCalibrationSize = FT4X6;
            }
            else {
                calResultPoint[0] = CGPointMake(penController.deviceCalibrationData_0.x, penController.deviceCalibrationData_0.y);
                calResultPoint[1] = CGPointMake(penController.deviceCalibrationData_1.x, penController.deviceCalibrationData_1.y);
                calResultPoint[2] = CGPointMake(penController.deviceCalibrationData_2.x, penController.deviceCalibrationData_2.y);
                calResultPoint[3] = CGPointMake(penController.deviceCalibrationData_3.x, penController.deviceCalibrationData_3.y);
                curCalibrationSize = Custom;
            }
            break;
        }
        case DIRECTION_BOTTOM: {
            FT_4X6_BOTTOM()
            if (CGPointEqualToPoint(penController.deviceCalibrationData_0, calResultPoint[0]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_1, calResultPoint[1]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_2, calResultPoint[2]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_3, calResultPoint[3])) {
                curCalibrationSize = FT4X6_BOTTOM;
            }
            else {
                calResultPoint[0] = CGPointMake(penController.deviceCalibrationData_0.x, penController.deviceCalibrationData_0.y);
                calResultPoint[1] = CGPointMake(penController.deviceCalibrationData_1.x, penController.deviceCalibrationData_1.y);
                calResultPoint[2] = CGPointMake(penController.deviceCalibrationData_2.x, penController.deviceCalibrationData_2.y);
                calResultPoint[3] = CGPointMake(penController.deviceCalibrationData_3.x, penController.deviceCalibrationData_3.y);
                curCalibrationSize = Custom;
            }
            break;
        }
        default: {
            //case DIRECTION_BOTH
            FT_8X5()
            if (CGPointEqualToPoint(penController.deviceCalibrationData_0, calResultPoint[0]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_1, calResultPoint[1]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_2, calResultPoint[2]) &&
                CGPointEqualToPoint(penController.deviceCalibrationData_3, calResultPoint[3])) {
                curCalibrationSize = FT8X5;
            }
            else {
                calResultPoint[0] = CGPointMake(penController.deviceCalibrationData_0.x, penController.deviceCalibrationData_0.y);
                calResultPoint[1] = CGPointMake(penController.deviceCalibrationData_1.x, penController.deviceCalibrationData_1.y);
                calResultPoint[2] = CGPointMake(penController.deviceCalibrationData_2.x, penController.deviceCalibrationData_2.y);
                calResultPoint[3] = CGPointMake(penController.deviceCalibrationData_3.x, penController.deviceCalibrationData_3.y);
                curCalibrationSize = Custom;
            }
            break;
        }
    }
    
    curDrawViewSize = [self GetDrawingSizeByCalibration];
    
    [penController setCalibrationData:CGRectMake(0, 0, curDrawViewSize.width, curDrawViewSize.height)
                          GuideMargin:0
                           CalibPoint:calResultPoint];
}

-(void) BLEState:(NSNotification *) obj {
    NSString* msg = @"";
    CBCentralManager * central = (CBCentralManager *) [obj object];
    switch (central.state) {
        case CBCentralManagerStateUnknown:
            msg = @"State unknown, update imminent.";
            break;
        case CBCentralManagerStateResetting:
            NSLog(@"The connection with the system service was momentarily lost, update imminent.");
            break;
        case CBCentralManagerStateUnsupported:
            NSLog(@"The platform doesn’t support Bluetooth Low Energy.");
            break;
        case CBCentralManagerStateUnauthorized:
            NSLog(@"The app is not authorized to use Bluetooth Low Energy.");
            break;
        case CBCentralManagerStatePoweredOff:
            NSLog(@"Bluetooth is currently powered off.");
            break;
        case CBCentralManagerStatePoweredOn:
            NSLog(@"Bluetooth is currently powered on and available to use.");
            [NSTimer scheduledTimerWithTimeInterval:1.0f
                                             target:self
                                           selector:@selector(showBLESearchMenu)
                                           userInfo:nil
                                            repeats:NO];
            break;
        default:
            break;
    }
}

-(void) BLESearchDeviceName:(NSNotification *) obj {
    NSLog(@"BLESearchDeviceName~~");
    NSMutableArray * bleObj = (NSMutableArray *) [obj object];
    if (self.m_BLESearchListController) {
        [self.m_BLESearchListController.deviceList addObject:bleObj];
        
        [NSTimer scheduledTimerWithTimeInterval:0.1f
                                         target:self
                                       selector:@selector(SearchListRefresh)
                                       userInfo:nil
                                        repeats:NO];
    }
}

-(void) SearchListRefresh {
    NSLog(@"SearchListRefresh~~");
    [self.m_BLESearchListController refresh];
}

#pragma mark - PenController
-(void) PenHandlerEnv:(NSArray*)info {
    if (isRecvEnvDataFirst) {
        isRecvEnvDataFirst = NO;
    }
}

-(void) ReadThreadStart {
    [self addDebugText:@"ReadThreadStart"];
    if (readThread == nil) {
        readThread = [[NSThread alloc] initWithTarget:self
                                             selector:@selector(runReadThread) object:self];
        readThreadStop=NO;
        readThreadPause=NO;
        [readThread start];
        
    }
    if (penController) {
        [penController StartReadQ];
    }
}

-(void) runReadThread {
    @autoreleasepool {
        while (1) {
            if (readThreadStop) {
                break;
            }
            NSDictionary* dic = [penController ReadQ];
            if(dic) {
                [self performSelectorOnMainThread:@selector(PenHandlerWithDictionary:) withObject:dic waitUntilDone:YES];
                [penController RemoveQ];
            }
            else {
                [NSThread sleepForTimeInterval:0.02];
            }
        }
    }
}
-(void) ReadThreadOff {
    [self addDebugText:@"ReadThreadOff"];
    readThreadStop = YES;
    [NSThread sleepForTimeInterval:0.2];
    if (readThread) {
        [readThread cancel];
        [readThread release];
        readThread = nil;
    }
    if (penController) {
        [penController EndReadQ];
    }
}

-(void) PleaseDoNotConnectDongleImpl {
    NSAlert* alert = [[[NSAlert alloc] init] autorelease];
    [alert setMessageText:@"Please connect with Bluetooth, not using USB dongle for mac user."];
    [alert addButtonWithTitle:@"OK"];
    [alert setAlertStyle:NSInformationalAlertStyle];
    [alert runModal];
}

-(void) PenCallBackFunc:(NSNotification *)call {
    NSString * szS = (NSString *) [call object];
    if([szS isEqualToString:@"BATTERY_INFO"]) {
        [batteryStationTextField setStringValue:[NSString stringWithFormat:@"%d%%", penController.battery_station]];
        
        if (penController.battery_station == -1)
            [batteryStationTextField setStringValue:@"No Data"];
        
        [batteryPenTextField setStringValue:[NSString stringWithFormat:@"%@", penController.battery_pen?@"LOW":@"HIGH"]];
    }
    else if([szS isEqualToString:@"NEW_PAGE"] || [szS isEqualToString:@"DUPLICATE_PAGE"]) {
        [self addDebugText:szS];
    }
    else if ([szS isEqualToString:@"DONGLE_CONNECTED"] || [szS isEqualToString:@"DONGLE_NOT_PAIRED_FIRST"] || [szS isEqualToString:@"DONGLE_NEW_PURCHASE"]) {
        [NSTimer scheduledTimerWithTimeInterval:0.01
                                         target:self
                                       selector:@selector(PleaseDoNotConnectDongleImpl)
                                       userInfo:nil
                                        repeats:NO];
    }
}
-(void) PenHandlerWithMsg:(NSNotification*) note {
    NSDictionary* dic = [note object];
    if ([penController getRetObj] != self)
        return;
    [self PenHandlerWithDictionary:dic];
}
-(void) PenHandlerWithDictionary:(NSDictionary*) dic {
    int PenStatus  = [[dic objectForKey:@"PenStatus"] intValue];
    CGPoint ptRaw = [[dic objectForKey:@"ptRaw"] pointValue];
    CGPoint ptConv = [[dic objectForKey:@"ptConv"] pointValue];
    int Temperature = [[dic objectForKey:@"Temperature"] intValue];
    int modelCode = [[dic objectForKey:@"modelCode"] intValue];
    int SMPenFlag = [[dic objectForKey:@"SMPenFlag"] intValue];
    int SMPenState = [[dic objectForKey:@"SMPenState"] intValue];
    int press = [[dic objectForKey:@"pressure"] intValue];
    [self PenHandlerWithArgs:ptRaw
                      ptConv:ptConv
                   PenStatus:PenStatus
                 Temperature:Temperature
                   ModelCode:modelCode
                   SMPenFlag:SMPenFlag
                  SMPenState:SMPenState
                    Pressure:press];
}
-(void) PenHandlerWithArgs:(CGPoint) Arg_ptRaw ptConv:(CGPoint) Arg_ptConv PenStatus:(int) Arg_PenStatus
               Temperature:(int) Arg_Temperature ModelCode:(int) Arg_modelCode
                SMPenFlag :(int) Arg_SMPenFlag SMPenState:(int) Arg_SMPenState
                  Pressure:(int) Arg_pressure {
    isRecvEnvDataFirst = YES;
    
    if (penController == nil) {
        [self addDebugText:@"PenController is not set"];
        return;
    }
    [statusTextField setStringValue:[NSString stringWithFormat:@"%d", Arg_PenStatus]];
    [rawXTextField setStringValue:[NSString stringWithFormat:@"%f", Arg_ptRaw.x]];
    [rawYTextField setStringValue:[NSString stringWithFormat:@"%f", Arg_ptRaw.y]];
    [convXTextField setStringValue:[NSString stringWithFormat:@"%f", Arg_ptConv.x]];
    [convYTextField setStringValue:[NSString stringWithFormat:@"%f", Arg_ptConv.y]];
    
    [self setPenPropertiesForSM:Arg_SMPenState];
    
    switch (Arg_PenStatus) {
        case PEN_DOWN:
            downCnt++;
            break;
        case PEN_MOVE:
            moveCnt++;
            break;
        case PEN_UP:
            upCnt++;
            break;
        case PEN_HOVER:
            break;
        default:
            break;
    }
    [self updateDrawCnt];
    if (beforeRawX == -1) {
        beforeRawX = Arg_ptRaw.x;
    }
    else {
        if (Arg_ptRaw.x-beforeRawX>1.0f) {
            errCntX++;
            [self updateErrCntX];
        }
    }
    if (beforeRawY == -1) {
        beforeRawY = Arg_ptRaw.y;
    }
    else {
        if (Arg_ptRaw.y-beforeRawY>1.0f) {
            errCntY++;
            [self updateErrCntY];
        }
    }
    
    if (self.m_DrawViewWindowController) {
        CGPoint p = CGPointMake(Arg_ptConv.x, self.m_DrawViewWindowController.drawView.frame.size.height-Arg_ptConv.y);
        BOOL erase = NO;
        BOOL big = NO;
        float eraseSize = 0.;
        if (([[propertiesTextField stringValue] isEqualToString:@"Erase Cap"] || [[propertiesTextField stringValue] isEqualToString:@"Erase Big"])) {
            erase = YES;
            if ([[propertiesTextField stringValue] isEqualToString:@"Erase Big"])
                big = YES;
            eraseSize = [penController calcSmartMarkerEraseThick:big];
        }
        [self.m_DrawViewWindowController SetDrawInfo:Arg_PenStatus pressure:Arg_pressure pt:p color:penColor erase:erase eraseSize:eraseSize];
    }
}
-(void) setPenPropertiesForSM:(int)Arg_SMPenState {
    NSString* smProperties = @"";
    switch (Arg_SMPenState) {
        case 0x51: // red marker
            smProperties = @"Red";
            penColor = [NSColor colorWithRed:1.0 green:0 blue:0 alpha:1];
            break;
        case 0x52: // green marker
            smProperties = @"Green";
            penColor = [NSColor colorWithRed:60.0/255.0 green:184.0/255.0 blue:120.0/255.0 alpha:1];
            break;
        case 0x53:
            smProperties = @"Yellow";
            penColor = [NSColor colorWithRed:1.0 green:1.0 blue:0 alpha:1];
            break;
        case 0x54:
            smProperties = @"Blue";
            penColor = [NSColor colorWithRed:0 green:0 blue:1.0 alpha:1];
            break;
        case 0x56:
            smProperties = @"Violet";
            penColor = [NSColor colorWithRed:128.0/255.0 green:0 blue:128.0/255.0 alpha:1];
            break;
        case 0x58:
            smProperties = @"Black";
            penColor = [NSColor colorWithRed:0 green:0 blue:0 alpha:1];
            break;
        case 0x59:  // eraser cap
            smProperties = @"Erase Cap";
            penColor = [NSColor colorWithRed:255./255. green:255./255. blue:255./255. alpha:1];
            break;
        case 0x50:
        case 0x5C:  // big eraser
            smProperties = @"Erase Big";
            penColor = [NSColor colorWithRed:255./255. green:255./255. blue:255./255. alpha:1];
            break;
        default:
            break;
    }
    [propertiesTextField setStringValue:smProperties];
}
- (IBAction)clearLog:(id)sender{
    [debugTextView setString:@""];
}

- (IBAction)packetCountClearClicked:(id)sender {
    packetCnt = 0;
    errCntX = 0;
    errCntY = 0;
    beforeRawX = -1;
    beforeRawY = -1;
    [self updateErrCntX];
    [self updateErrCntY];
    [self updatePacketCnt];
}
- (IBAction)countClearClicked:(id)sender{
    downCnt = 0;
    moveCnt= 0;
    upCnt = 0;
    [self updateDrawCnt];
}
- (IBAction)volumechanged:(id)sender {
    int value = AUDIO_DEV_MAX-(int)[volumeSlider doubleValue];
    [penController changeVolume:value];
}
- (IBAction)audioModeClicked:(id)sender {
    [penController changeAudioMode:[audioModeBtn selectedSegment] == 0 ? NO : YES];
}

-(CGSize) GetDrawingSizeByCalibration {
    if (penController.bConnected) {
        CGSize caliSize = [penController getCalibrationSize];
        float calcW = 0.;
        float calcH = 0.;
        
        float w = caliSize.width;
        float h = caliSize.height;
        calcW = curScreenSize.width;
        calcH = (int)((h*curScreenSize.width)/w);
        if (calcH > curScreenSize.height) {
            calcH = curScreenSize.height;
            calcW = (int)((w*curScreenSize.height)/h);
        }
        
        return CGSizeMake(calcW, calcH);
    }
    
    return CGSizeMake(curScreenSize.width, curScreenSize.height);
}

- (IBAction)bleDisconnectClicked:(id)sender {
    if ([self checkViewController]) {
        return;
    }
    
    if (!penController.bConnected) {
        return;
    }
    
    [self closeAllViewController];
    
    [penController BLEDisconnect];
}

#pragma mark - BLESearchListController
- (IBAction)bleSearchClicked:(id)sender {
    if ([self checkViewController]) {
        return;
    }
    
    if (penController.bConnected) {
        return;
    }
    
    [self closeAllViewController];
    
    self.m_BLESearchListController = [[[BLESearchListController alloc] initWithWindowNibName:@"BLESearchListController"] autorelease];
    self.m_BLESearchListController.delegate = self;
    [self.m_BLESearchListController.deviceList removeAllObjects];
    [self.m_BLESearchListController showWindow:self];
    [penController BLEScan];
}

-(void) closeBLESearchListViewController {
    [penController BLEScanStop];
    
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeAllViewController)
                                   userInfo:nil
                                    repeats:NO];
}

-(void) selectBLEDevice:(CBPeripheral *)peripheral {
    [penController BLEConnect:peripheral];
    [self closeBLESearchListViewController];
}
#pragma mark BLESearchListController End

#pragma mark - CalibrationViewWindowController
- (IBAction)calibrationClicked:(id)sender {
    if ([self checkViewController]) {
        return;
    }
    
    if (!penController.bConnected) {
        NSAlert* alert = [[[NSAlert alloc] init] autorelease];
        [alert addButtonWithTitle:@"Ok"];
        [alert setMessageText:@"Connect receiver first."];
        [alert setAlertStyle:NSInformationalAlertStyle];
        [alert beginSheetModalForWindow:self.window
                          modalDelegate:nil
                         didEndSelector:nil
                            contextInfo:NULL];
        return;
    }
    
    [self closeAllViewController];
    
    self.m_MarkerCalibrationViewController = [[[MarkerCalibrationViewController alloc] initWithWindowNibName:@"MarkerCalibrationViewController"] autorelease];
    self.m_MarkerCalibrationViewController.delegate = self;
    self.m_MarkerCalibrationViewController.penController = penController;
    [self.m_MarkerCalibrationViewController showWindow:self];
}

-(void) successMarkerCalibrationViewController:(CGPoint[])calResultPoint{
    curCalibrationSize = Custom;
    curDrawViewSize = [self GetDrawingSizeByCalibration];
    
    [penController setCalibrationData:CGRectMake(0, 0, curDrawViewSize.width, curDrawViewSize.height)
                          GuideMargin:0
                           CalibPoint:calResultPoint];
    
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    
    if (penController.StationPosition == DIRECTION_LEFT) {
        [directionTextField setStringValue:@"Left"];
    }
    else if (penController.StationPosition == DIRECTION_RIGHT) {
        [directionTextField setStringValue:@"Right"];
    }
    else if (penController.StationPosition == DIRECTION_TOP) {
        [directionTextField setStringValue:@"Top"];
    }
    else if (penController.StationPosition == DIRECTION_BOTTOM) {
        [directionTextField setStringValue:@"Bottom"];
    }
    else {
        [directionTextField setStringValue:@"Both"];
    }
    
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeAllViewController)
                                   userInfo:nil
                                    repeats:NO];
}
-(void) closeMarkerCalibrationViewController {
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeAllViewController)
                                   userInfo:nil
                                    repeats:NO];
    
}

#pragma mark CalibrationViewWindowController End



#pragma mark - BTNameChangeViewController
- (IBAction)bleNameChangeClicked:(id)sender {
    if ([self checkViewController]) {
        return;
    }
    
    if (!penController.bConnected) {
        NSAlert* alert = [[[NSAlert alloc] init] autorelease];
        [alert addButtonWithTitle:@"Ok"];
        [alert setMessageText:@"Connect receiver first."];
        [alert setAlertStyle:NSInformationalAlertStyle];
        [alert beginSheetModalForWindow:self.window
                          modalDelegate:nil
                         didEndSelector:nil
                            contextInfo:NULL];
        return;
    }
    
    [self closeAllViewController];
    
    self.m_BTNameChangeViewController = [[[BTNameChangeViewController alloc] initWithWindowNibName:@"BTNameChangeViewController"] autorelease];
    self.m_BTNameChangeViewController.delegate = self;
    self.m_BTNameChangeViewController.penController = penController;
    [self.m_BTNameChangeViewController showWindow:self];
}

-(void) successBTNameChangeViewController {
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeAllViewController)
                                   userInfo:nil
                                    repeats:NO];
}

-(void) closeBTNameChangeViewController {
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeAllViewController)
                                   userInfo:nil
                                    repeats:NO];
}

#pragma mark BTNameChangeViewController End

#pragma mark - VoiceChangeViewController
- (IBAction)voiceChangeClicked:(id)sender {
    if ([self checkViewController]) {
        return;
    }
    
    if (!penController.bConnected) {
        NSAlert* alert = [[[NSAlert alloc] init] autorelease];
        [alert addButtonWithTitle:@"Ok"];
        [alert setMessageText:@"Connect receiver first."];
        [alert setAlertStyle:NSInformationalAlertStyle];
        [alert beginSheetModalForWindow:self.window
                          modalDelegate:nil
                         didEndSelector:nil
                            contextInfo:NULL];
        return;
    }
    
    [self closeAllViewController];
    
    self.m_VoiceChangeViewController = [[[VoiceChangeViewController alloc] initWithWindowNibName:@"VoiceChangeViewController"] autorelease];
    self.m_VoiceChangeViewController.delegate = self;
    self.m_VoiceChangeViewController.penController = penController;
    [self.m_VoiceChangeViewController showWindow:self];
}

-(void) successVoiceChangeViewController {
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeAllViewController)
                                   userInfo:nil
                                    repeats:NO];
}

-(void) closeVoiceChangeViewController {
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeAllViewController)
                                   userInfo:nil
                                    repeats:NO];
}

#pragma mark VoiceChangeViewController End

#pragma mark - DrawViewWindowController
- (IBAction)drawingClicked:(id)sender {
    if ([self checkViewController]) {
        return;
    }
    
    if (!penController.bConnected) {
        NSAlert* alert = [[[NSAlert alloc] init] autorelease];
        [alert addButtonWithTitle:@"Ok"];
        [alert setMessageText:@"Connect receiver first."];
        [alert setAlertStyle:NSInformationalAlertStyle];
        [alert beginSheetModalForWindow:self.window
                          modalDelegate:nil
                         didEndSelector:nil
                            contextInfo:NULL];
        return;
    }
    
    [self closeAllViewController];
    
    self.m_DrawViewWindowController = [[[DrawViewWindowController alloc] initWithWindowNibName:@"DrawViewWindowController"] autorelease];
    self.m_DrawViewWindowController.delegate = self;
    self.m_DrawViewWindowController.penController = penController;
    self.m_DrawViewWindowController.calibrationSize = curCalibrationSize;
    self.m_DrawViewWindowController.drawViewSize = curDrawViewSize;
    [self.m_DrawViewWindowController showWindow:self];
}

-(void) closeDrawViewWindowController {
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeAllViewController)
                                   userInfo:nil
                                    repeats:NO];
}

#pragma mark DrawViewWindowController End

-(void) showBLESearchMenu {
    [bleSearchBtn setEnabled:YES];
    [bleDisconnectBtn setEnabled:YES];
}

-(BOOL) checkViewController {
    if (self.m_BLESearchListController) {
        return YES;
    }
    if (self.m_DrawViewWindowController) {
        return YES;
    }
    if (self.m_MarkerCalibrationViewController) {
        return YES;
    }
    if (self.m_BTNameChangeViewController) {
        return YES;
    }
    if (self.m_VoiceChangeViewController) {
        return YES;
    }
    
    return NO;
}

-(void) closeAllViewController {
    if (self.m_BLESearchListController) {
        [self.m_BLESearchListController close];
        self.m_BLESearchListController = nil;
    }
    if (self.m_DrawViewWindowController) {
        [self.m_DrawViewWindowController close];
        self.m_DrawViewWindowController = nil;
    }
    if (self.m_MarkerCalibrationViewController) {
        [self.m_MarkerCalibrationViewController close];
        self.m_MarkerCalibrationViewController = nil;
    }
    if (self.m_BTNameChangeViewController) {
        [self.m_BTNameChangeViewController close];
        self.m_BTNameChangeViewController = nil;
    }
    if (self.m_VoiceChangeViewController) {
        [self.m_VoiceChangeViewController close];
        self.m_VoiceChangeViewController = nil;
    }
}
@end
